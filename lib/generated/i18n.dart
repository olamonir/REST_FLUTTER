import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

// This file is automatically generated. DO NOT EDIT, all your changes would be lost.
class S implements WidgetsLocalizations {
  const S();

  static S current;

  static const GeneratedLocalizationsDelegate delegate =
    GeneratedLocalizationsDelegate();

  static S of(BuildContext context) => Localizations.of<S>(context, S);

  @override
  TextDirection get textDirection => TextDirection.ltr;

  String get about_us => "About Us";
  String get contact_us => "Contact Us";
  String get email => "Email";
  String get error_try_again => "Error please try again";
  String get fill_field => "Please fill this field";
  String get home => "Home";
  String get message => "Message";
  String get message_send_content => "Your message send successfully.";
  String get name => "Name";
  String get ok => "OK";
  String get send => "Send";
  String get share_app => "Share app";
  String get developed_by => "Developed by";
  String get facebook => "Facebook";
  String get twitter => "Twitter";
  String get whats_app => "Whats app";
  String get about_us_content => "R.E.S.T is the acronym for Researcher Essential Statical Tool, which is afree application available to all researchers that leads you to the suggested statical test of your research data based on the purpose of the research, type of data, and its distribution.I put in your hands my simple knoledge and experience in the field of statical analysis, doing mistakes can happened for sure so, please don't hesitate to inform me if you found any mistake to correct it, because the goal of R.E.S.T. is serve the scientific research and researchers.";




}

class $ar extends S {
  const $ar();

  @override
  TextDirection get textDirection => TextDirection.rtl;


  @override
  String get about_us => "عن التطبيق";
  @override
  String get name => "الأسم";
  @override
  String get send => "إرسال";
  @override
  String get message_send_content => "تم أرسال رسالتك بنجاح.";
  @override
  String get contact_us => "تواصل معنا";
  @override
  String get ok => "موافق";
  @override
  String get email => "البريد";
  @override
  String get fill_field => "قم بملئ هذه الخانه";
  @override
  String get message => "الرساله";
  @override
  String get home => "الرئيسيه";
  @override
  String get error_try_again => "خطأ اعد المحاوله";
  @override
  String get share_app => "مشاركة التطبيق";
  @override
  String get developed_by => "برمجة وتصميم";
  @override
  String get facebook => "فيس بوك";
  @override
  String get twitter => "تويتر";
  @override
  String get whats_app => "واتس آب";
  @override
  String get about_us_content => "Developed by";

}

class $en extends S {
  const $en();
}

class GeneratedLocalizationsDelegate extends LocalizationsDelegate<S> {
  const GeneratedLocalizationsDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale("ar", ""),
      Locale("en", ""),
    ];
  }

  LocaleListResolutionCallback listResolution({Locale fallback, bool withCountry = true}) {
    return (List<Locale> locales, Iterable<Locale> supported) {
      if (locales == null || locales.isEmpty) {
        return fallback ?? supported.first;
      } else {
        return _resolve(locales.first, fallback, supported, withCountry);
      }
    };
  }

  LocaleResolutionCallback resolution({Locale fallback, bool withCountry = true}) {
    return (Locale locale, Iterable<Locale> supported) {
      return _resolve(locale, fallback, supported, withCountry);
    };
  }

  @override
  Future<S> load(Locale locale) {
    final String lang = getLang(locale);
    if (lang != null) {
      switch (lang) {
        case "ar":
          S.current = const $ar();
          return SynchronousFuture<S>(S.current);
        case "en":
          S.current = const $en();
          return SynchronousFuture<S>(S.current);
        default:
          // NO-OP.
      }
    }
    S.current = const S();
    return SynchronousFuture<S>(S.current);
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale, true);

  @override
  bool shouldReload(GeneratedLocalizationsDelegate old) => false;

  ///
  /// Internal method to resolve a locale from a list of locales.
  ///
  Locale _resolve(Locale locale, Locale fallback, Iterable<Locale> supported, bool withCountry) {
    if (locale == null || !_isSupported(locale, withCountry)) {
      return fallback ?? supported.first;
    }

    final Locale languageLocale = Locale(locale.languageCode, "");
    if (supported.contains(locale)) {
      return locale;
    } else if (supported.contains(languageLocale)) {
      return languageLocale;
    } else {
      final Locale fallbackLocale = fallback ?? supported.first;
      return fallbackLocale;
    }
  }

  ///
  /// Returns true if the specified locale is supported, false otherwise.
  ///
  bool _isSupported(Locale locale, bool withCountry) {
    if (locale != null) {
      for (Locale supportedLocale in supportedLocales) {
        // Language must always match both locales.
        if (supportedLocale.languageCode != locale.languageCode) {
          continue;
        }

        // If country code matches, return this locale.
        if (supportedLocale.countryCode == locale.countryCode) {
          return true;
        }

        // If no country requirement is requested, check if this locale has no country.
        if (true != withCountry && (supportedLocale.countryCode == null || supportedLocale.countryCode.isEmpty)) {
          return true;
        }
      }
    }
    return false;
  }
}

String getLang(Locale l) => l == null
  ? null
  : l.countryCode != null && l.countryCode.isEmpty
    ? l.languageCode
    : l.toString();
